---
title: LP03-Python的数据结构
author: Xiaojun Sun
date: '2019-04-02'
slug: lp03-python的数据结构
categories:
  - Learn Python
tags:
  - Python
---



<div id="section" class="section level3">
<h3>标量类型</h3>
<p><img src="http://ww1.sinaimg.cn/large/748b26cfly1g1nicb4warj20jg05e3ys.jpg" /></p>
<div id="none" class="section level4">
<h4>None</h4>
<p>None是Python的空值类型。如果一个函数没有明确的返回值，就会默认返回None。None也常常作为函数的默认参数。None不仅是一个保留字，还是唯一的NoneType的实例：</p>
<pre class="python"><code>type(None)   #NoneType</code></pre>
</div>
<div id="section-1" class="section level4">
<h4>字符串</h4>
<p>你可以用单引号或双引号来表示字符串。反斜杠 <code>\</code> 可以用来转义，被用来表示特殊字符 。</p>
<pre class="python"><code>print(&#39;&quot;Yes,&quot; they said.&#39;)</code></pre>
<pre><code>## &quot;Yes,&quot; they said.</code></pre>
<pre class="python"><code>print(&quot;\&quot;Yes,\&quot; they said.&quot;)</code></pre>
<pre><code>## &quot;Yes,&quot; they said.</code></pre>
<pre class="python"><code>print(&#39;&quot;Isn\&#39;t,&quot; they said.&#39;)</code></pre>
<pre><code>## &quot;Isn&#39;t,&quot; they said.</code></pre>
<p>如果字符串中包含许多反斜杠，但没有特殊字符，这样做就很麻烦。幸好，可以在字符串前面加一个<code>r</code>，表明<code>/</code>字符就是它自身，<code>r</code>的含义是原始字符串raw：</p>
<pre class="python"><code>s = r&#39;this\has\no\special\characters&#39;
print(s)</code></pre>
<pre><code>## this\has\no\special\characters</code></pre>
<p>字符串字面值可以跨行连续输入。一种方式是用三重引号：<code>"""..."""</code> 或 <code>'''...'''</code>。字符串中的回车换行会自动包含到字符串中，如果不想包含，在行尾添加一个 <code>\</code> 即可。如下例：</p>
<pre class="python"><code>print(&quot;&quot;&quot;Line 1
Line 2
Line 3
&quot;&quot;&quot;)</code></pre>
<pre><code>## Line 1
## Line 2
## Line 3</code></pre>
<p>字符串可以用 <code>+</code> 进行连接（粘到一起），也可以用 <code>*</code> 进行重复：</p>
<pre class="python"><code>3 * &#39;un&#39; + &#39;ium&#39;</code></pre>
<pre><code>## &#39;unununium&#39;</code></pre>
<p>相邻的两个或多个 <em>字符串字面值</em> （引号引起来的字符）将会自动连接到一起。只能对两个字面值这样操作，变量或表达式不行。如果你想连接变量，或者连接变量和字面值，可以用 <code>+</code> 号。</p>
<pre class="python"><code>&#39;Py&#39; &#39;thon&#39;</code></pre>
<pre><code>## &#39;Python&#39;</code></pre>
<pre class="python"><code>pre = &#39;py&#39;
pre + &#39;thon&#39;</code></pre>
<pre><code>## &#39;python&#39;</code></pre>
<p>字符串是可以被 <em>索引</em> （下标访问）的，第一个字符索引是 0。单个字符并没有特殊的类型，只是一个长度为一的字符串：</p>
<pre class="python"><code>word = &#39;Python&#39;
word[0]  #&#39;P&#39;
word[-1] #&#39;n&#39;</code></pre>
<p>除了索引，字符串还支持 <em>切片</em>。索引可以得到单个字符，而 <em>切片</em> 可以获取子字符串。注意切片的开始总是被包括在结果中，而结束不被包括。这使得 <code>s[:i] + s[i:]</code> 总是等于 <code>s</code>。</p>
<pre class="python"><code>word[:2] #&#39;Py&#39;</code></pre>
<p>Python 中的字符串不能被修改，它们是 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-immutable">immutable</a> 的。因此，向字符串的某个索引位置赋值会产生错误。</p>
<p>在Python 3中推荐使用<a href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#formatted-string-literals">f-Strings</a> 进行字符串格式化。f-strings 是指以 <code>f</code> 或 <code>F</code> 开头的字符串，其中以 <code>{}</code> 包含的表达式会进行值替换。</p>
<pre class="python"><code>name = &#39;hoxis&#39;
age = 18
f&quot;hi, {name}, are you {age}&quot;</code></pre>
<pre><code>## &#39;hi, hoxis, are you 18&#39;</code></pre>
<p>因为 f-strings 是在运行时计算的，那么这就意味着你可以在其中放置任意合法的 Python 表达式，比如：</p>
<pre class="python"><code>f&quot;{ 2 * 3 + 1}&quot;</code></pre>
<pre><code>## &#39;7&#39;</code></pre>
<pre class="python"><code>import math
print(f&#39;The value of pi is approximately {math.pi:.3f}.&#39;)</code></pre>
<pre><code>## The value of pi is approximately 3.142.</code></pre>
</div>
<div id="section-2" class="section level4">
<h4>数字</h4>
<p>数字的二元运算符包括：</p>
<p><img src="http://ww1.sinaimg.cn/large/748b26cfly1g1nib2pknxj20mj0elt8u.jpg" /></p>
<pre class="python"><code>(30 - 2 * 3) / 5</code></pre>
<pre><code>## 4.8</code></pre>
<p>在交互模式下，上一次打印出来的表达式被赋值给变量 <code>_</code>：</p>
<pre class="python"><code>2 + _  #6.8</code></pre>
<p>可以把比较式串在一起: <code>a&gt;b&gt;c&gt;d</code>：</p>
<pre class="python"><code>5&gt;2&gt;3&gt;1</code></pre>
<pre><code>## False</code></pre>
</div>
</div>
<div id="list" class="section level3">
<h3>列表list</h3>
<p>list是Python内置的一种数据类型，list是一种有序的集合，可以随时添加和删除其中的元素。比如，列出班里所有同学的名字，就可以用一个list表示：</p>
<pre class="python"><code>classmates = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]</code></pre>
<p>用<code>len()</code>函数可以计算list中元素的个数。用索引可以访问list中每一个位置的元素，记得索引是从<code>0</code>开始的，最后一个元素的索引是<code>len(classmates) - 1</code> ，还可以用<code>-1</code>做索引直接获取最后一个元素；用<code>-2</code>做索引，可以直接获取倒数第二个元素。</p>
<p>list是一个可变的有序表。</p>
<pre class="python"><code># 可以往list中追加元素到末尾
classmates.append(&#39;Adam&#39;)
#用extend方法可以追加多个元素
classmates.extend(&#39;Jony&#39;,&#39;Tom&#39;)
# 也可以把元素插入到指定的位置
classmates.insert(1, &#39;Jack&#39;)
# 可以用pop()方法删除list中的元素
classmates.pop(2)
#可以直接赋值给对应的索引位置
classmates[1] = &#39;Sarah&#39;
# 可以把元素插入到指定的位置
classmates.insert(1, &#39;Jack&#39;)
#list里面的元素的数据类型也可以不同
L = [&#39;Apple&#39;, 123, True]
#list的元素也可以是另一个list
s = [&#39;python&#39;, &#39;java&#39;, [&#39;asp&#39;, &#39;php&#39;], &#39;scheme&#39;]
#用in可以检查列表是否包含某个值
&#39;java&#39; in s  #TRUE
#可以用加号将两个列表串联起来，但没有extend好
[4, None, &#39;foo&#39;] + [7, 8, (2, 3)]
#[4, None, &#39;foo&#39;, 7, 8, (2, 3)]
#排序方法
s.sort()
s.sort(key=len) #二级排序key
#切片
s[1:3]; s[-2:]</code></pre>
</div>
<div id="tuple" class="section level3">
<h3>元组tuple</h3>
<p>另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改。</p>
<pre class="python"><code>classmates = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;)</code></pre>
<p>现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用<code>classmates[0]</code>，<code>classmates[-1]</code>，但不能赋值成另外的元素。不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。</p>
<p>只有1个元素的tuple定义时必须加一个逗号<code>,</code>，来消除歧义</p>
<pre class="python"><code>t = (1,)
t</code></pre>
<pre><code>## (1,)</code></pre>
<p>可以用加号运算符将元组串联起来：</p>
<pre class="python"><code>(4, None, &#39;foo&#39;) + (6, 0) + (&#39;bar&#39;,)</code></pre>
<pre><code>## (4, None, &#39;foo&#39;, 6, 0, &#39;bar&#39;)</code></pre>
<p>拆分元组</p>
<pre class="python"><code>tup = (4, 5, 6)
a, b, c = tup
a, b = 1, 2
b, a = a, b
values = 1, 2, 3, 4, 5
a, b, *rest = values</code></pre>
</div>
<div id="dict" class="section level3">
<h3>字典dict</h3>
<p>Python内置了字典（dict），dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p>
<pre class="python"><code>d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85}
d[&#39;Michael&#39;]</code></pre>
<pre><code>## 95</code></pre>
<p>给定一个名字，比如<code>'Michael'</code>，dict在内部就可以直接计算出<code>Michael</code>对应的存放成绩的“页码”，也就是<code>95</code>这个数字存放的内存地址，直接取出来，所以速度非常快。</p>
<pre class="python"><code>#把数据放入dict，除了初始化时指定外，还可以通过key放入
d[&#39;Adam&#39;] = 67
#删除一个key
d.pop(&#39;Bob&#39;)
#dict可以接受2元元组的列表</code></pre>
<pre><code>## 75</code></pre>
<pre class="python"><code>mapping = dict(zip(range(5), reversed(range(5))))</code></pre>
<p>dict内部存放的顺序和key放入的顺序是没有关系的。和list比较，dict有以下几个特点：</p>
<ol style="list-style-type: decimal">
<li>查找和插入的速度极快，不会随着key的增加而变慢；</li>
<li>需要占用大量的内存，内存浪费多。</li>
</ol>
<p>而list相反：</p>
<ol style="list-style-type: decimal">
<li>查找和插入的时间随着元素的增加而增加；</li>
<li>占用空间小，浪费内存很少。</li>
</ol>
<p>所以，dict是用空间来换取时间的一种方法。</p>
<p>dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是<strong>不可变对象</strong>。</p>
<p>这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key。</p>
</div>
<div id="set" class="section level3">
<h3>集合set</h3>
<p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以在set中没有重复的key。</p>
<p>要创建一个set，需要提供一个list作为输入集合：</p>
<pre class="python"><code>s = set([1, 2, 3])</code></pre>
<p>注意，传入的参数<code>[1, 2, 3]</code>是一个list，而显示的<code>{1, 2, 3}</code>只是告诉你这个set内部有1，2，3这三个元素，显示的顺序也不表示set是有序的。。</p>
<p>重复元素在set中自动被过滤：</p>
<pre class="python"><code>s = set([1, 1, 2, 2, 3, 3])</code></pre>
<pre class="python"><code># 可以添加元素到set中
s.add(4)
# 可以删除元素
s.remove(4) </code></pre>
<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p>
<pre class="python"><code>s1 = set([1, 2, 3])
s2 = set([2, 3, 4])
s1 &amp; s2</code></pre>
<pre><code>## {2, 3}</code></pre>
<pre class="python"><code>s1 | s2</code></pre>
<pre><code>## {1, 2, 3, 4}</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/748b26cfly1g1nicb4wppj20jb0cjt8r.jpg" /></p>
</div>
<div id="section-3" class="section level3">
<h3>不可变对象</h3>
<p>str是不变对象，而list是可变对象。对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：</p>
<pre class="python"><code>a = [&#39;c&#39;, &#39;b&#39;, &#39;a&#39;]
a.sort()</code></pre>
<p>而对于不可变对象，比如str，对str进行操作：</p>
<pre class="python"><code>a = &#39;abc&#39;
a.replace(&#39;a&#39;, &#39;A&#39;)</code></pre>
<pre><code>## &#39;Abc&#39;</code></pre>
<pre class="python"><code>a</code></pre>
<pre><code>## &#39;abc&#39;</code></pre>
</div>
<div id="section-4" class="section level3">
<h3>序列函数</h3>
<div id="enumerate" class="section level4">
<h4>enumerate函数</h4>
<p><code>enumerate</code>函数可以返回<code>(i, value)</code>元组序列</p>
<pre class="python"><code>for i, v in enumerate(some_list):
    mapping[v] = i</code></pre>
</div>
<div id="sorted" class="section level4">
<h4>sorted函数</h4>
<p><code>sorted</code>函数可以从任意序列的元素返回一个新的排好序的列表，<code>sorted</code>函数可以接受和<code>sort</code>方法相同的参数。</p>
<pre class="python"><code>sorted([7, 1, 2, 6, 0, 3, 2])</code></pre>
<pre><code>## [0, 1, 2, 2, 3, 6, 7]</code></pre>
</div>
<div id="zip" class="section level4">
<h4>zip函数</h4>
<p><code>zip</code>可以将多个列表、元组或其它序列成对组合成一个元组列表：</p>
<pre class="python"><code>seq1 = [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;]
seq2 = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]
zipped = zip(seq1, seq2)
zipped</code></pre>
<pre><code>## &lt;zip object at 0x0000000025F8C288&gt;</code></pre>
<p><code>zip</code>可以处理任意多的序列，元素的个数取决于最短的序列。<code>zip</code>的常见用法之一是同时迭代多个序列，可能结合<code>enumerate</code>使用 。</p>
<p><code>zip</code>也可以当作把行的列表转换为列的列表（很神奇）。</p>
<pre class="python"><code>pitchers = [(&#39;Nolan&#39;, &#39;Ryan&#39;), (&#39;Roger&#39;, &#39;Clemens&#39;), (&#39;Schilling&#39;, &#39;Curt&#39;)]
first_names, last_names = zip(*pitchers)
first_names;last_names</code></pre>
<pre><code>## (&#39;Nolan&#39;, &#39;Roger&#39;, &#39;Schilling&#39;)
## (&#39;Ryan&#39;, &#39;Clemens&#39;, &#39;Curt&#39;)</code></pre>
</div>
</div>
<div id="section-5" class="section level3">
<h3>列表推导式</h3>
<p>列表推导式(list comprehensions)是Python最受喜爱的特性之一。它允许用户方便的从一个集合过滤元素，形成列表，在传递参数的过程中还可以修改元素。</p>
<pre class="python"><code>[expr for val in collection if condition]
dict_comp = {key-expr : value-expr for value in collection if condition} #字典
set_comp = {expr for value in collection if condition} #集合</code></pre>
<p>举例如下：</p>
<pre class="python"><code>print([i**2 for i in range(20) if i % 3 is 0])</code></pre>
<pre><code>## [0, 9, 36, 81, 144, 225, 324]</code></pre>
<pre class="python"><code>mcase = {&#39;a&#39;: 10, &#39;b&#39;: 34}
print({v: k for k, v in mcase.items()})</code></pre>
<pre><code>## {10: &#39;a&#39;, 34: &#39;b&#39;}</code></pre>
<pre class="python"><code>print({x**2 for x in [1, 1, 2]})</code></pre>
<pre><code>## {1, 4}</code></pre>
<p>嵌套列表推导式，包含两层for循环：</p>
<pre class="python"><code>some_tuples = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
flattened = [x for tup in some_tuples for x in tup if x&gt;5]
flattened</code></pre>
<pre><code>## [6, 7, 8, 9]</code></pre>
</div>
